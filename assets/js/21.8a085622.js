(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{273:function(a,t,v){"use strict";v.r(t);var _=v(38),e=Object(_.a)({},function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h3",{attrs:{id:"无重复字符的最长子串"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#无重复字符的最长子串","aria-hidden":"true"}},[a._v("#")]),a._v(" 无重复字符的最长子串")]),a._v(" "),v("p",[a._v("先说一下我的思路，后面再更新官方思路。")]),a._v(" "),v("h3",{attrs:{id:"我的思路"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#我的思路","aria-hidden":"true"}},[a._v("#")]),a._v(" 我的思路")]),a._v(" "),v("ol",[v("li",[a._v("遍历字符串的每一个字符。")]),a._v(" "),v("li",[a._v("用一个数组保存当前符合条件的字符，如果遇到重复字符，就应该把当前的长度保存起来，供后续比较。")]),a._v(" "),v("li",[a._v("并且把第一次出现的这个字符以及之前的字符去掉。")]),a._v(" "),v("li",[a._v("最后比较之前存下来的长度值，找出最大的返回。")])]),a._v(" "),v("p",[a._v("这个想法的关键是找出分割位置，而我发现的分割位置就是重复字符的第一次出现这个字符的位置。有点绕口，举个例子：")]),a._v(" "),v("p",[a._v("假设我们有"),v("code",[a._v('"cabacda"')]),a._v("。当我们遍历到第二个a时，我们发现a已经出现过了，那么我们就把ca舍弃掉，把cab这个长度保存起来作为第一个可能答案。")]),a._v(" "),v("p",[a._v("即以第一个a为分界线。因为这样当前就不会有重复字符。")]),a._v(" "),v("h3",{attrs:{id:"官方思路"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#官方思路","aria-hidden":"true"}},[a._v("#")]),a._v(" 官方思路")]),a._v(" "),v("p",[a._v("除了暴力法（即检测每一个子字符串），官方用到的就是所谓'滑动窗口'法。其实也就是我的思路。")]),a._v(" "),v("blockquote",[v("p",[a._v("滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)[i,j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j)[i,j) 向右滑动 11 个元素，则它将变为 [i+1, j+1)[i+1,j+1)（左闭，右开）。")])]),a._v(" "),v("p",[a._v("另外在评论区中看到一个优化，在我的思路中只有到遍历到终点才会结束，不过其实只用判断左窗口到终点的长度小于已有最大长度就可以结束了。")])])},[],!1,null,null,null);t.default=e.exports}}]);